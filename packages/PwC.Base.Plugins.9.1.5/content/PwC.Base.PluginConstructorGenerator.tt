<#
/*
	T4 template for generating constructors for passing crm plugin configurations
	Restrictions: Only generates constructors when types:
	-are in the same project as the template;
	-are not static;
*/
#>
<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop.8.0" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ output extension=".cs" #>
// <auto-generated />
using System;
using System.CodeDom.Compiler;
<#
	// To debug, uncomment the next two lines !! 
	// System.Diagnostics.Debugger.Launch();
	// System.Diagnostics.Debugger.Break();

	this.dte = (DTE)((IServiceProvider)this.Host).GetService(typeof(SDTE));

	MarkTemplateUnsaved();

	var namespaces = (
		from @class in GetAllClassesThatNeedAConstructor()
		group @class by @class.Namespace.Name into g
		orderby g.Key
		select new { Name = g.Key, Classes = g.ToArray() })
		.ToArray();

	foreach (var @namespace in namespaces)
    {
		this.NewLine();
		this.WriteNamespace(@namespace.Name, @namespace.Classes);
	}
#>
<#+
//private const string OnCreatedPartialMethod = "OnCreated";
private DTE dte;

private void WriteNamespace(string namespaceName, IEnumerable<CodeClass2> classes)
{
	this.WriteLine("namespace " + namespaceName);
	using (this.BeginBrackets())
    {
		foreach (var @class in classes)
		{
			if (classes.First() != @class)
			{
					this.NewLine();
            }

			this.WriteLine("// " + @class.ProjectItem.Name);
			WriteClass(@class);
		}
    }
}

private void WriteClass(CodeClass2 @class)
{
	MarkClassAsPartial(@class);

	this.WriteLine("{0} partial class {1}", GetAccess(@class.Access), GetClassName(@class));

	using (this.BeginBrackets())
    {
		this.WriteConstructor(@class);
    }
}

private void WriteConstructor(CodeClass2 @class)
{
	WriteConstructorDefinition(@class);

	using (this.BeginBrackets())
	{
	}
}

private void WriteConstructorDefinition(CodeClass2 @class)
{
	this.WriteLine(@"[GeneratedCode(""PwC.Base.PluginConstructorGenerator"", ""1.0"")]");
	this.Write("public " + @class.Name + "(");
	this.WriteLine("string unsecureString, string secureString)");
	this.PushIndent();
	this.WriteLine(": base(unsecureString, secureString)");
	this.PopIndent();
}

private void MarkTemplateUnsaved()
{
    ProjectItem projectItem = GetTheProjectItemForThisT4Template();

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(Constants.vsViewKindCode);

    // Mark the .tt file as unsaved. This way it will be saved and update itself next time the
    // project is built. Basically, it keeps marking itself as unsaved to make the next build work.
    // Note: this is certainly hacky, but is the best I could come up with so far.
    projectItem.Document.Saved = false;
}

private Project GetCurrentProject() 
{
    return GetTheProjectItemForThisT4Template().ContainingProject;
}

private ProjectItem GetTheProjectItemForThisT4Template()
{
    return dte.Solution.FindProjectItem(this.Host.TemplateFile);
}

private IEnumerable<CodeClass2> GetAllClassesThatNeedAConstructor()
{
	// GetAllClassesThatNeedAConstructorRecursive returns all partials of the same type.
	// The groupby type.ProjectItem.Name ensures we only return one of those partials.
	return
		from ProjectItem projectItem in GetCurrentProject().ProjectItems
		from type in GetAllClassesThatNeedAConstructorRecursive(projectItem)
		group type by type.ProjectItem.Name into g
		select g.First();
}

private IEnumerable<CodeClass2> GetAllClassesThatNeedAConstructorRecursive(ProjectItem projectItem)
{
	var queryTypes = GetAllClassesThatNeedAConstructor(projectItem);

	var recursiveQueryTypes = 
		from ProjectItem subItem in projectItem.ProjectItems
		from type in GetAllClassesThatNeedAConstructorRecursive(subItem)
		select type;

	return queryTypes.Union(recursiveQueryTypes);
}

private IEnumerable<CodeClass2> GetAllClassesThatNeedAConstructor(ProjectItem projectItem)
{	
	if (projectItem.FileCodeModel == null)
    {
		return Enumerable.Empty<CodeClass2>();
    }
	
	var elements = projectItem.FileCodeModel.CodeElements.OfType<object>().ToArray();

	var namespacedTypes =
		from @namespace in projectItem.FileCodeModel.CodeElements.OfType<CodeNamespace>()
		from type in @namespace.Members.OfType<CodeClass2>()
		select type;

	var rootTypes = projectItem.FileCodeModel.CodeElements.OfType<CodeClass2>();

	return
		from type in rootTypes.Union(namespacedTypes)
		where IsClassThatNeedsAConstructor(type)
		select type;
}

private bool IsClassThatNeedsAConstructor(CodeClass2 type)
{
	if (this.TypeIsGeneratedByThisTemplate(type))
    {
		return false;
    }

	var constructors =
		from partialClass in type.PartialClasses.OfType<CodeClass2>()
		where !this.TypeIsGeneratedByThisTemplate(partialClass)
		from constructor in GetConstructors(partialClass)
		select constructor;

	return !type.IsShared && !constructors.Any() && this.TypeIsPluginBaseImplementation(type);
}

private bool TypeIsGeneratedByThisTemplate(CodeClass2 type)
{
	string templateName = Path.GetFileNameWithoutExtension(this.Host.TemplateFile);

	return Path.GetFileNameWithoutExtension(type.ProjectItem.Name) == templateName;
}

private bool TypeIsPluginBaseImplementation(CodeClass2 type)
{
	foreach (CodeElement2 @base in type.Bases.OfType<CodeElement2>()) 
	{
		if (@base.FullName.StartsWith("PwC.Base.Plugins.PluginBase<")) 
		{
			return true;
		}
	}
	return false;
}

private IEnumerable<CodeFunction2> GetConstructors(CodeClass2 type)
{
	return
		from CodeElement2 member in type.Members
		let function = member as CodeFunction2
		where function != null
		where function.FunctionKind == vsCMFunction.vsCMFunctionConstructor
		where !function.IsShared
		select function;
}

private string GetAccess(vsCMAccess access)
{
    switch (access)
    {
		case vsCMAccess.vsCMAccessPublic:
			return "public";
        default:
			return "internal";
    }
}

private void MarkClassAsPartial(CodeClass2 type)
{
	if (type.DataTypeKind != vsCMDataTypeKind.vsCMDataTypeKindPartial)
    {
		type.DataTypeKind = vsCMDataTypeKind.vsCMDataTypeKindPartial;
    }
}

private string GetClassName(CodeClass2 type)
{
	return type.FullName.Substring(type.FullName.IndexOf(type.Name));
}

private void PushIndent()
{
	this.PushIndent("    ");
}

private void NewLine()
{
	this.WriteLine(string.Empty);
}

private IDisposable BeginBrackets()
{
	this.WriteLine("{");
	this.PushIndent();

	return new EndBrackets(this);
}

private sealed class EndBrackets : IDisposable
{
	private readonly GeneratedTextTransformation template;

	public EndBrackets(GeneratedTextTransformation template)
    {
		this.template = template;
    }

	public void Dispose()
    {
		this.template.PopIndent();
		this.template.WriteLine("}");
    }
}
#>